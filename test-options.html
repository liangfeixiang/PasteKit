<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Options é¡µé¢æµ‹è¯•</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .btn-primary { background-color: #007bff; color: white; }
        .btn-success { background-color: #28a745; color: white; }
        .btn-danger { background-color: #dc3545; color: white; }
        textarea, input {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
        }
        .result {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
            display: none;
        }
        .success { background-color: #d4edda; color: #155724; }
        .error { background-color: #f8d7da; color: #721c24; }
        .info { background-color: #d1ecf1; color: #0c5460; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”§ Options é¡µé¢åŠŸèƒ½æµ‹è¯•</h1>
        
        <div class="test-section">
            <h2>ğŸ” ç§˜é’¥é…ç½®æµ‹è¯•</h2>
            <textarea id="testPublicKey" rows="4" placeholder="å…¬é’¥"></textarea>
            <textarea id="testPrivateKey" rows="4" placeholder="ç§é’¥"></textarea>
            <input type="text" id="testAesKey" placeholder="AESå¯†é’¥">
            <input type="text" id="testAesIv" placeholder="AES IV (å¯é€‰)">
            
            <button class="btn-primary" onclick="saveTestKeys()">ä¿å­˜ç§˜é’¥</button>
            <button class="btn-success" onclick="loadTestKeys()">åŠ è½½ç§˜é’¥</button>
            <button class="btn-danger" onclick="clearTestKeys()">æ¸…ç©ºç§˜é’¥</button>
            
            <div id="keyResult" class="result"></div>
        </div>
        
        <div class="test-section">
            <h2>ğŸ§ª åŠ å¯†è§£å¯†æµ‹è¯•</h2>
            <textarea id="testText" rows="3" placeholder="æµ‹è¯•æ–‡æœ¬">Hello World! æµ‹è¯•æ¶ˆæ¯</textarea>
            <select id="algorithmSelect">
                <option value="RSA">RSA</option>
                <option value="AES/CBC/PKCS5Padding">AES/CBC/PKCS5Padding</option>
                <option value="AES/ECB/PKCS5Padding">AES/ECB/PKCS5Padding</option>
            </select>
            
            <button class="btn-primary" onclick="testEncryption()">åŠ å¯†</button>
            <button class="btn-success" onclick="testDecryption()">è§£å¯†</button>
            <button onclick="fullTest()">å®Œæ•´æµ‹è¯•</button>
            
            <textarea id="encryptedResult" rows="3" placeholder="åŠ å¯†ç»“æœ" readonly></textarea>
            <textarea id="decryptedResult" rows="3" placeholder="è§£å¯†ç»“æœ" readonly></textarea>
            
            <div id="testResult" class="result"></div>
        </div>
    </div>

    <script>
        // æ¨¡æ‹Ÿ Chrome storage API
        const mockStorage = {
            data: {},
            async set(items) {
                Object.assign(this.data, items);
                console.log('Mock storage set:', items);
            },
            async get(keys) {
                if (Array.isArray(keys)) {
                    const result = {};
                    keys.forEach(key => {
                        result[key] = this.data[key];
                    });
                    return result;
                } else if (typeof keys === 'string') {
                    return { [keys]: this.data[keys] };
                } else {
                    return this.data;
                }
            },
            async remove(key) {
                delete this.data[key];
                console.log('Mock storage removed:', key);
            }
        };

        // å¦‚æœä¸åœ¨ Chrome ç¯å¢ƒä¸­ï¼Œä½¿ç”¨æ¨¡æ‹Ÿå­˜å‚¨
        const storage = typeof chrome !== 'undefined' && chrome.storage ? chrome.storage.local : mockStorage;

        function showMessage(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.className = `result ${type}`;
            element.style.display = 'block';
        }

        async function saveTestKeys() {
            try {
                const keys = {
                    publicKey: document.getElementById('testPublicKey').value.trim(),
                    privateKey: document.getElementById('testPrivateKey').value.trim(),
                    aesKey: document.getElementById('testAesKey').value.trim(),
                    aesIv: document.getElementById('testAesIv').value.trim(),
                    timestamp: Date.now()
                };

                if (!keys.aesKey) {
                    showMessage('keyResult', 'âŒ AESå¯†é’¥ä¸èƒ½ä¸ºç©º', 'error');
                    return;
                }

                await storage.set({ encryptionKeys: keys });
                showMessage('keyResult', 'âœ… ç§˜é’¥ä¿å­˜æˆåŠŸï¼', 'success');
            } catch (error) {
                showMessage('keyResult', `âŒ ä¿å­˜å¤±è´¥: ${error.message}`, 'error');
            }
        }

        async function loadTestKeys() {
            try {
                const result = await storage.get(['encryptionKeys']);
                if (result.encryptionKeys) {
                    const keys = result.encryptionKeys;
                    document.getElementById('testPublicKey').value = keys.publicKey || '';
                    document.getElementById('testPrivateKey').value = keys.privateKey || '';
                    document.getElementById('testAesKey').value = keys.aesKey || '';
                    document.getElementById('testAesIv').value = keys.aesIv || '';
                    showMessage('keyResult', 'ğŸ“¥ ç§˜é’¥åŠ è½½æˆåŠŸï¼', 'info');
                } else {
                    showMessage('keyResult', 'ğŸ“‹ æš‚æ— ä¿å­˜çš„ç§˜é’¥', 'info');
                }
            } catch (error) {
                showMessage('keyResult', `âŒ åŠ è½½å¤±è´¥: ${error.message}`, 'error');
            }
        }

        async function clearTestKeys() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰ç§˜é’¥å—ï¼Ÿ')) {
                try {
                    await storage.remove('encryptionKeys');
                    document.getElementById('testPublicKey').value = '';
                    document.getElementById('testPrivateKey').value = '';
                    document.getElementById('testAesKey').value = '';
                    document.getElementById('testAesIv').value = '';
                    showMessage('keyResult', 'ğŸ—‘ï¸ ç§˜é’¥å·²æ¸…ç©º', 'info');
                } catch (error) {
                    showMessage('keyResult', `âŒ æ¸…ç©ºå¤±è´¥: ${error.message}`, 'error');
                }
            }
        }

        async function testEncryption() {
            const plaintext = document.getElementById('testText').value.trim();
            const algorithm = document.getElementById('algorithmSelect').value;
            
            if (!plaintext) {
                showMessage('testResult', 'âŒ è¯·è¾“å…¥æµ‹è¯•æ–‡æœ¬', 'error');
                return;
            }

            try {
                let config;
                let ciphertext;

                switch (algorithm) {
                    case 'RSA':
                        const rsaKeys = await getRSAKeys();
                        // ç®€å•çš„ Base64 ç¼–ç æ¨¡æ‹Ÿ RSA åŠ å¯†
                        ciphertext = btoa(plaintext);
                        break;

                    case 'AES/CBC/PKCS5Padding':
                    case 'AES/ECB/PKCS5Padding':
                        const aesKeys = await getAESKeys();
                        // ç®€å•çš„å¼‚æˆ–åŠ å¯†æ¨¡æ‹Ÿ AES
                        ciphertext = simpleXorEncrypt(plaintext, aesKeys.key);
                        break;

                    default:
                        throw new Error(`ä¸æ”¯æŒçš„ç®—æ³•: ${algorithm}`);
                }

                document.getElementById('encryptedResult').value = ciphertext;
                showMessage('testResult', `âœ… ${algorithm} åŠ å¯†æˆåŠŸï¼`, 'success');
            } catch (error) {
                showMessage('testResult', `âŒ åŠ å¯†å¤±è´¥: ${error.message}`, 'error');
                document.getElementById('encryptedResult').value = '';
            }
        }

        async function testDecryption() {
            const ciphertext = document.getElementById('encryptedResult').value.trim();
            const algorithm = document.getElementById('algorithmSelect').value;
            
            if (!ciphertext) {
                showMessage('testResult', 'âŒ è¯·è¾“å…¥å¯†æ–‡', 'error');
                return;
            }

            try {
                let config;
                let plaintext;

                switch (algorithm) {
                    case 'RSA':
                        const rsaKeys = await getRSAKeys();
                        // ç®€å•çš„ Base64 è§£ç æ¨¡æ‹Ÿ RSA è§£å¯†
                        plaintext = atob(ciphertext);
                        break;

                    case 'AES/CBC/PKCS5Padding':
                    case 'AES/ECB/PKCS5Padding':
                        const aesKeys = await getAESKeys();
                        // ç®€å•çš„å¼‚æˆ–è§£å¯†æ¨¡æ‹Ÿ AES
                        plaintext = simpleXorDecrypt(ciphertext, aesKeys.key);
                        break;

                    default:
                        throw new Error(`ä¸æ”¯æŒçš„ç®—æ³•: ${algorithm}`);
                }

                document.getElementById('decryptedResult').value = plaintext;
                showMessage('testResult', `âœ… ${algorithm} è§£å¯†æˆåŠŸï¼`, 'success');
            } catch (error) {
                showMessage('testResult', `âŒ è§£å¯†å¤±è´¥: ${error.message}`, 'error');
                document.getElementById('decryptedResult').value = '';
            }
        }

        async function fullTest() {
            const originalText = document.getElementById('testText').value.trim();
            const algorithm = document.getElementById('algorithmSelect').value;
            
            if (!originalText) {
                showMessage('testResult', 'âŒ è¯·è¾“å…¥æµ‹è¯•æ–‡æœ¬', 'error');
                return;
            }

            try {
                showMessage('testResult', `ğŸ§ª æ­£åœ¨æ‰§è¡Œ ${algorithm} å®Œæ•´æµ‹è¯•...`, 'info');
                
                // åŠ å¯†
                await testEncryption();
                const ciphertext = document.getElementById('encryptedResult').value;
                
                if (!ciphertext) {
                    throw new Error('åŠ å¯†å¤±è´¥');
                }

                // è§£å¯†
                await testDecryption();
                const decryptedText = document.getElementById('decryptedResult').value;
                
                // éªŒè¯
                if (originalText === decryptedText) {
                    showMessage('testResult', `âœ… ${algorithm} å®Œæ•´æµ‹è¯•é€šè¿‡ï¼`, 'success');
                } else {
                    showMessage('testResult', `âŒ ${algorithm} æµ‹è¯•å¤±è´¥ï¼åŸæ–‡ä¸è§£å¯†ç»“æœä¸ä¸€è‡´ã€‚`, 'error');
                }

            } catch (error) {
                showMessage('testResult', `âŒ å®Œæ•´æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }

        async function getRSAKeys() {
            const result = await storage.get(['encryptionKeys']);
            const keys = result.encryptionKeys;
            
            if (!keys || !keys.publicKey || !keys.privateKey) {
                throw new Error('è¯·å…ˆé…ç½®RSAå…¬é’¥å’Œç§é’¥');
            }
            
            return {
                publicKey: keys.publicKey,
                privateKey: keys.privateKey
            };
        }

        async function getAESKeys() {
            const result = await storage.get(['encryptionKeys']);
            const keys = result.encryptionKeys;
            
            if (!keys || !keys.aesKey) {
                throw new Error('è¯·å…ˆé…ç½®AESå¯†é’¥');
            }
            
            return {
                key: keys.aesKey,
                iv: keys.aesIv || ''
            };
        }

        // ç®€å•çš„ XOR åŠ å¯†å‡½æ•°ï¼ˆä»…ç”¨äºæ¼”ç¤ºï¼‰
        function simpleXorEncrypt(text, key) {
            let result = '';
            for (let i = 0; i < text.length; i++) {
                result += String.fromCharCode(text.charCodeAt(i) ^ key.charCodeAt(i % key.length));
            }
            return btoa(result); // Base64 ç¼–ç 
        }

        function simpleXorDecrypt(encrypted, key) {
            const text = atob(encrypted); // Base64 è§£ç 
            let result = '';
            for (let i = 0; i < text.length; i++) {
                result += String.fromCharCode(text.charCodeAt(i) ^ key.charCodeAt(i % key.length));
            }
            return result;
        }

        // é¡µé¢åŠ è½½æ—¶å°è¯•åŠ è½½å·²ä¿å­˜çš„ç§˜é’¥
        document.addEventListener('DOMContentLoaded', async () => {
            await loadTestKeys();
        });
    </script>
</body>
</html>